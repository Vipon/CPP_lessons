0. rvalue и lvalue ссылки
	rvalue и lvalue ссылки относятся к объектам стоящим слева и справа относительно оператора присваивания.
	lvalue относится к объекту с идентифицируемым местом в памяти.
	rvalue относится к объекту, который занимает неидентифицируемое метсо в памяти.
	Поэтому lvalue не может относиться к временным объектам.
	чтобы сделать r(l)value ссылку, нужно добавть &(&&) после типа:

int val;
int& lref = a // lvalue ссылка

int val;
int&& rref = a // rvalue ссылка

1. Списки инициализации - метод инициализации членов класса прямо в классе.
	Покажем, что станет со следующим классом:

class Bottle
{
public:
	Bottle()
	{
	size_t hight = 25;
	}
private:
	size_t hight;
};

	используя списки инициализации, имеем: 

class Bottle
{
public:
	Bottle(): hight(25) {}
private:
	size_t hight;
};

	В списках инициализации можно инициализировать констнты, а порядок инициализации согласуется 
с порядком деклорации:

class Constants
{
public:
	Constnants(): pi(4), exp(3) {} // инициализируется сначала е, а потом пи
private:
	const size_t exp, pi;
};

2. Типы контсрукторов
	Есть 2 типа конструкторов (которые я знаю) - это конструктор копирования и конструктор move.

КОНСТРУКТОР КОПИРОВАНИЯ:

	В С++ копирование происходит побитно, поэтому при присваивании объектов с динамически выделенной памятью,
они будут ссылаться на одну и ту же область памяти. При использовании delete эта область памяти освободится при первом вызове, 
а при втором вызовется исключение, т.к. область памяти уже пуста.
	Чтобы избежать такой ситуации, есть конструктор копирования, который копирует не побитово, а целый объект. Конструктор имеет вид

Class_name_left (const Class_name_right &ref)
{
...
}

MOVE КОНСТРУКТОР:

	Если right_Class-у предстоит исчезнуть, нужно использовать move конструктор. Конструктор имеет вид 

Class_name_left (Class_name_right &&ref) :
{
...
}

3. Использование const в методах класса
	const гарантирует, что не изменится значение аргумента или поле класса функции:
type func (const class_name& ref);	- функция не меняет поля класса по ссылке ref.
type func (...) const; - функция не меняет поля класса.

4. Оператор в C++ - это функция, обозначаемая специальным символом, т.е. отличие опреатора от обычной функции только в синтаксисе:

class val1, val2, val3;
val3 = val1 + val2; // все равно, что val3 = val1.sum(val2);

	Операторы можно перегружать, но нельзя изменить приоритет операторов, количество операндов, а операторы , :: * и ? не 
могут быть перегружены.
	Синтаксис перегрузки имеет следующий вид: (на примере)

class Integer
{
private:
    int val;
public:
    Integer(int i): val(i) {}
    const Integer operator+(const Integer& second) const {
        return (val + second.val);
    }
};

5. Ключевое слово friend используется, чтобы предоставить функции доступ к полю private класса, чьим методом она не является или
для предоставления одному классу доступ к полю private другого.
	В частности, используется для перегрузки оператора << :
friend std::ostream& operator<<(std::ostream& stream, const class_name& member);

6. Отличие new и delete от malloc и free в том, что первые кроме выделения и освобождения памяти вызывают соответствующий конструктор
и деструктор, а в случае неудачи new вызывает исключение (когда malloc возвращает NULL).