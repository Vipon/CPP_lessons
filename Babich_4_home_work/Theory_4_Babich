0. Ключевое слово static используется следующим образом:
	I) static-переменная (функция) вне класса или структуры может быть определена и имеет ровно одно состояние только в области видимости, где переменная (функция) была создана.
	II) statiс-переменная внутри структуры или класса имеет только одно состояние во всех экземплярах структуры или класса. При этом к static переменным нужно обращаться определенным образом:
	name_class::variable.
	То есть variable становится членом соответсвующего пространства имен, это хорошо видно на примере:

	name_class class1;
	name_class::variable = 1; //вместо class1.variable = 1
	name_class class2;
	name_class::variable = 2; //вместо class1.variable = 2
	class1.print_var();
	class2.print_var();

	Будет напечатано 2 и 2.

	static методы не зависят от экземпляров класса (т.е. принадлежат пространству имен class_name(static метод - это то же самое, что метод вне класса, зависящий от класса как от параметра)), к ним имеют доступ только static переменные. Обращение к static методам происходит следующим образом: name_class::method(...).

	Т.е. наш фрагмент можно переписать так:

	name_class class1;
	name_class::variable = 1; //вместо class1.variable = 1
	name_class class2;
	name_class::variable = 2; //вместо class1.variable = 2
	name_class::print_var();  //вместо class1.print_var();
	name_class::print_var();  //вместо class2.print_var();

1. Наследование позволяет создавать производные классы, сохраняющие методы и элементы базового  и имеющие дополнительные методы или элементы.

2. При public наследовании сохраняется доступ предков к полям public и protected базового класса , но для них не доступно поле private базового класса.

3. Указатели (ссылки) на базовый класс и производный имеют одинаковый тип (потому что базовый и производный классы имеют одинаковй тип), но по этому указателю нельзя получть доступ к уникальным объектам производного.

4. Виртуальные функции нужны чтобы переписывать методы базового класса в производных. Проблемы могут возникнуть, когда метод, наследованный от базововго класса, отличается от оригинального. Тогда при вызове этого метода в производном классе вызовется этот же метод в базовом. 
	С помощью ключевого слова virtual можно создавать виртуальные методы, которые нормально вызываются в производных классах.
Так же стоит после переписанной функции в производном классе ставить ключевое слово override, чтобы убедиться, что в базовом классе существует виртуальная функция, соответствующая данной.










