0. Классы памяти

В языке Си существует четыре класса памяти:

Автоматический (automatic)
Регистровый (register)
Статический (static)
Внешний (external)

a) Автоматический (automatic)
По умолчанию, локальные переменные имеют класс auto. Такие переменные располагаются на стеке, а их область видимости ограничена своим блоком. Auto говорит компилятору о том, что локальная переменная, перед именем которой он стоит, создаётся при входе в блок и разрушается при выходе из блока. 

Пример:
int nVar = 5;

b) Регистровый (register)

Регистр — устройство для записи, хранения и считывания n-разрядных двоичных данных и выполнения других операций над ними.

Регистровая переменная располагалается в регистре, а не в оперативной памяти. Компилятор может сделать переменную регистровой, если позволяют условия (регистры не заняты, и по мнению компилятора это не приведёт к увеличению издержек). Регистровые переменные определяются с помощью служебного слово register перед типом:

register int x = 20 

Так как регистровая переменная не имеет адреса, то к ней не применима операция взятия адреса, это вызовет ошибку во время компиляции. Аргументы функции также могут быть заданы как register. Внутри функции они будут вести себя также, как и регистровые переменные.
Время жизни и область видимости такие же, как у автоматической.

c) Статический (static)
Спецификатор static указывает компилятору на хранение локальной переменной во время всего жизненного цикла программы вместо ее создания и разрушения при каждом входе в область действия и выходе из неё. Следовательно, возведение локальных переменных в ранг статистических позволяет поддерживать их значения между вызовами функций.

Модификатор static можно также применять к глобальным переменным. В этом случае область видимости такой переменной ограничивается файлом, в котором она объявлены, это означает, что переменная будет иметь внутреннюю привязку. Внутренняя привязка говорит о том, что индикатор известен только внутри своего файла. Если функция объявлена как static, то она видна только в своём файле. Из другого файла к static функции обратиться нельзя.

Пример статической ф-ии:

static int staticFunc(int nVar) //статическая
      {
        return ++nVar;
      }

d) Внешний (external)
Внешние переменные вводятся как противоположные автоматическим. Это глобальные переменные и к ним можно обращаться именами из любой функции. Поскольку внешние переменные доступны везде, их можно использовать для связи между функциями, не пренебрегая механизму формальных параметров.

Класс памяти extern в Си используем в двух случаях:

если переменная объявляется в программе ниже, чем ссылка на неё;
если переменная объявлена в другом модуле.
Пример:

#include <stdio.h>
int x=145; //Описание внешней переменной
main()
{
extern int x,y;
printf("x=%d y=%d \n",x,y);
}
int y=541; //Описание внешней переменной

Внешние переменные могут определятся вне какой-либо функции при этом выделяется фактическая память. В любой другой функции, обращающейся к этим переменным, они должны описываться с помощью описателя extern.

Время жизни постоянное. Область видимости глобальная (все файлы).


1.  Способы управления областями видимости в языке С

В простейших случаях область видимости определяется местом объявления идентификатора. В случаях, когда место объявления не может однозначно задать область видимости, применяются специальные уточнения:

a) Идентификатор, объявленный вне любого определения функции, процедуры, типа, является глобальным.

b) Идентификатор, объявленный внутри определения функции, является локальным в данной функции, то есть его областью видимости является эта функция.

c) Идентификатор, являющийся частью определения типа данных, в отсутствие дополнительных уточнений имеет ту же область видимости, что и идентификатор типа, в определение которого он входит.


2.0. способы управления областями видимости в языке С++

К способам, перечисленным выше, добавляются еще два:

c) идентификатор, объявленный вне всех процедур и классов, по умолчанию относится к модулю, пакету или пространству имён, внутри которого находится его объявление. Сами пределы области видимости для пакета или пространства имён указываются с помощью специальных описаний, а модульная область видимости ограничивается текущим файлом исходного текста программы. Особенностью этого типа видимости является то, c++, содержит средства, позволяющие сделать идентификатор доступным и вне своего модуля (пакета или пространства имён), то есть «расширить» его область видимости. 

d) Область видимости идентификатора, объявленного внутри класса, по умолчанию является приватной. Иная область видимости придаётся с помощью специального описания (модификаторы private, public, protected).

2.1. Namaspace
Пространство имен определяет область кода, в которой гарантируется уникальность всех идентификаторов.Чтобы избежать ситуаций, когда два независимых фрагмента кода имеют имена, которые конфликтуют друг с другом при совместном использовании, C++ позволяет объявлять собственные пространства имен через ключевое слово namespace. Всё, что объявлено внутри пользовательского пространства имен, принадлежит только этому пространству имен, а не глобальному.

namespace MyNameSpace {
    int i, k;
    void myfunc(int j) { cout << j; }
}

Доступ к пространству имен через осуществляется через оператор разрешения области видимости (::). К нему добавляется префикс названия пространства имен, которое нам нужно.
Если члены пространства имен будут использоваться часто, то для упрощения доступа к ним можно применить директиву using. Оператор using имеет две общие формы записи.

using namespace имя;
using имя::член;


3.Ключевые слова public: и private:

public, private — это модификаторы доступа.

Public — доступ открыт всем, кто видит определение данного класса.
Private — доступ открыт самому классу (т.е. функциям-членам данного класса) и друзьям (friend) данного класса, как функциям, так и классам.

4. Конструктор и деструктор класса

конструктор  – это специальный метод класса, который предназначен для инициализации элементов класса некоторыми начальными значениями.

деструктор (от слова destruct — разрушать) — специальный метод класса, который служит для уничтожения элементов класса. Чаще всего его используют тогда, когда в конструкторе,при создании объекта класса, динамически был выделен участок памяти и необходимо эту память очистить, если эти значения уже не нужны для дальнейшей работы программы.

Св-ва:

a) конструктор и деструктор всегда public;

b) при объявлении конструктора, тип данных возвращаемого значения не указывается;

c) у деструктора также нет типа данных для возвращаемого значения, к тому же деструктору нельзя передавать никаких параметров;

d) имя класса и конструктора должно быть идентично;

e) имя деструктора идентично имени конструктора, но с приставкой ~ ;

f)В классе допустимо создавать несколько конструкторов, если это необходимо. Имена, согласно пункту 2 нашего списка, будут одинаковыми. Компилятор будет их различать по передаваемым параметрам (как при перегрузке функций). Если мы не передаем в конструктор параметры, он считается конструктором по умолчанию;

g) в классе может быть объявлен только один деструктор;


5. New и delete
В языке С++ для динамического выделения и освобождения памяти используются опреаторы new и delete.

Их общая форма имеет вид:

переменная_указатель = new тип_переменной;
delete переменная_указатель; 

С помощью new можно размещать массивы. Общая форма для одномерного массива имеет вид:

переменная_указатель = new тип_переменной [размер];

Для освобождения динамически размещенного массива необходимо использовать следующую форму оператора delete:

delete [] переменная_указатель;


6. Указатель this
 — это указатель на адрес объекта класса, при этом он  является скрытым первым параметром любого метода класса (кроме статических методов), а типом указателя выступает имя класса. 

a)this является зарезервированным словом С++;

b) мы можем использовать this явно в методах-элементах класса;

c) объявить, инициализировать либо изменить указатель this возможности нет;


7. std::cout and std::cin

объект std::cout (который находится в библиотеке iostream) используется для вывода текста в консольное окно. Например:

#include <iostream>
 
int main()
{
   int b = 5;
   std::cout << "b is " << b;
   return 0;
}
Программа выведет:
b is 5

std::cin получает данные от пользователя с помощью оператора ввода >>. Используя std::cin мы можем получать данные от пользователя и сохранять их в переменные.

#include <iostream>
 
int main()
{
   std::cout << "Enter a number: "; // просим пользователя ввести любое число
   int a = 0;
   std::cin >> a; // получаем число с консольного окна и сохраняем его в переменную a
   std::cout << "You entered " << a << std::endl;
   return 0;
}