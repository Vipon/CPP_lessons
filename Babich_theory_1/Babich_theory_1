I-III. Сигнатура фнкции - часть объявления, содержащая название функци, кол-во и типы передаваемых аргументов.
Одинаковыми сигнатурами будут

void func (int* val1, char* val2);
float func (int* val1, char* val2);

Одинаковыми сигнатурами будут

void func (int* val1, float* val2);
void func (int* val1, char* val2);

Полиморфизм позволяет использовать функцию с фиксированным названием как разные, изменяя её сигнатуру.

Перегрузка функции - вид полиморфизма, позволяющий использовать одноименные функции с разными сигнатурами.
Перегрузка может осуществляться как во 2м примере , с помощью шаблона или аргументов по умолчанию.

IV. Аргументы по умолчанию:

int func(int val1, int valdef = 0) {...}

Здесь valdef- аргумент по умолчанию, если вызвать функцию в виде func(1), то аргуенты будут иметь значения 1 и 0 соответственно, а если в виде func(1,1), то 1 и 1.

V-VI. Шаблон функции - конструкция, создающая экземпляры функции с определенным набором параметров. Шаблон копирует код функции с соответствующими вставками. При этом экземпляр создается, если в программе осуществляется вызов данной функции с данными параметрами. Шаблон может описывать функцию не от всех параметров, от каких хотелось бы, поэтому существует явная специализация шаблона: пишется код, согласно которому функция будет себя вести при нетипичном параметре. Например

template <typename T>
void print(T val) {std::cout << val; }
- синтаксис шаблона функции. Вызвать ее можно так: func<int>(5) //напечатается 5//, а можно так: 
func<char>(gospodi_pomilui) //напечатается gospodi_pomilui//

Но, например, для комплексного числа эта функция не сработает. Напишем явную специализацию шаблона.

template <> void print<complex>(complex val) {//что-то невероятное//}

Теперь при вызове print от комплексного числа скопируется код специализации.

VII. Ссылка в языке C++ - это форма указателя, которая сильно упрощает код. Ссылка не может менять своего значения и должна сразу инициализироваться, также ссылка может использоваться как указатель, но обращение к элементу некоторой структуры через ссылку осуществляется с помощью знака ".", а не "->". Объявление ссылки:

char pushkin = "ы";
int &sibir = pushkin // здесь sibir - это ссылка на pushkin

VIII. Ключевое слово inline используется в объявлении функции, тогда она назыается встроенной. При вызове встроенной функции на место вызова в коде вставляется код функции. Это сильно ускоряет программу, например, если использовать рекурсию как встроенную функцию.

IX. decltype и auto - ключевые слова, позволяющие определить тип выражения, часто используются в шаблонах. У них есть некотороые особенности:
auto:

auto var = expression;
если expression имеет тип T* или const T*, то var имеет тот же типж

auto var = expression;
если expression имеет тип T , const T, T& или const T& то var имеет тип T.
То есть auto отбрасывает CV-квалификаторы.

auto& var = expression;
В данном случае expression не может иметь тип T или const T, т.к. var должна быть lvalue ссылка

В случае auto&& var = expression; тип var зависит от value-категории expression (T& или T&&)

Также auto нельзя использовать как параметр функции.

decltype:

decltype(var) имеет тот же тип, что и var, если var - объявленная переменная.
Если var - некторое выражение, то decltype(var) имеет тип T&, const T& или T&&, const T&&, если выражение возвращает lvalue или rvalue ссылку соответственно.

Также можно писать decltype(auto) var = expression, чтобы не терять CV-квалификаторы. Можно было бы написать 
decltype(expresion), но expression может быть на пару строк.





