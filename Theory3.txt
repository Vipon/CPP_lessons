0.  lvalue и rvalue ссылки.
Свои имена они получили благодаря фразам: right value(rvalue), т.е. выражение находящиеся справа и left value(lvalue), т.е. выражение находящееся слева от оператора присваивания.
lvalue представляет собой объект, который занимает идентифицируемое место в памяти (например, имеет адрес).
rvalue — это выражение, которое не представляет собой объект, который занимает идентифицируемое место в памяти.
По семантике lvalue ссылка формируется путём помещая & после некоторого типа.

int a;
int& ref1 = a;  // это lvalue ссылка

Если после некоторого типа поместить &&, то получится rvalue ссылка.

int a;
int&& ref2 = a;  // это rvalue ссылка

Rvalue ссылка ведет себя точно так же, как и lvalue ссылка, за исключением того, что она может быть связана с временным объектом, тогда как lvalue связать с временным (не константным) объектом нельзя.

int x = 5;
inr& r1 = x; //Ok
int& r2 = 10; //Error

int&& r3 = x; //Error
int&& r4 = 10; //Ok

1. Списки инициализации -  метод инициализации переменных-членов класса вместо присваивания им значений после объявления.
Например, с использованием списков инициализации конструктор класса

class Values
{
public:
    Values()
    {
        m_value = 10;
    }
private:
    int m_value;
};

примет вид:

 Values() : m_value(10) // напрямую инициализируем переменные-члены класса
    {
    // Нет необходимости использовать присваивание
    }

Кроме того, списки инициализации позволяют инициализировать константы, которым нельзя присваивать значения:

class Values
{
public:
    Values()
    {
        m_value = 10; //ERROR
    }


    Values() : m_value(10) {} //OK


private:
    const int m_value;
};

В списке инициализации переменные инициализируются порядке декларации, а не в том порядке, в котором они были пречислены в строке.
Например,

class A {
public:
  A() : b(8), a(7) {} //Сначала инициализируется a, потом b.

private:
  int a;
  int b;
};



2. Типы конструкторов: конструктор копирования, move конструктор.
Конструктор копирования используется для инициализации одного объекта другим.
По умолчанию при инициализации одного объекта другим С++ выполняет побитовое копирова­ние. Но такой способ далеко не всегда может использоваться. Например, если при инициализации объекта динамически выделяется память, то копия объекта будет ссылаться на тот же участок памяти.
Для решения подобных проблем язык С++ позволяет создать конструктор копирования, кото­рый используется компилятором, когда один объект инициализирует другой. При наличии кон­структора копирования побитовое копирование не выполняется. Общая форма конструктора ко­пирования имеет вид:

Class_name (const Class_name &ref) 
{
// тело конструктора
}

Здесь о является ссылкой на объект в правой части инициализации. Конструктор копирования может иметь также дополнительные параметры, если для них определены значения по умолча­нию. Однако в любом случае первым параметром должна быть ссылка на объект, выполняющий инициализацию.

Move constructor вызывается вместо конструктора копирования в случае, когда объект, из которого создается копия, вот-вот будет уничтожен. В таком конструкторе обычно данные из временного объекта переносятся в новый объект, а не копируютя, а полям временного объекта присваиваются валидные значения (например, указателям присваиваются значения nullptr). При выходе из move constructor оба объекта должны оставаться валидными и для обоих должен корректно отрабатывать деструктор. Ссылка T&& называется rvalue reference и означает ссылку на объект, который вот-вот будет уничтожен. Общая форма move конструктора имеет вид:

Class_name (Class_name && ref) :
{
// тело конструктора
}


3. Использование const в методах классов позволяет гарантировать, что функция не меняет значений аргумента или поля класса.
Функция int func1(const Class_name& c) не изменяет поля класса по ссылке с.
Const после объявления метода класса ( size_t size() const;) показывает, что данный метод не изменяет поля класcа.


4. Оператор в С++ - это некоторое действие или функция обозначенная специальным символом. Для того что бы распространять эти действия на новые типы данных, при этом сохраняя естественный синтаксис, в С++ была введена возможность перегрузки операторов. 
Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>). Например,

class Integer
{
private:
    int value;
public:
    Integer(int i): value(i) 
    {}
    const Integer operator+(const Integer& rv) const {
        return (value + rv.value);
    }
};

Имеются некоторые ограничения на перегрузку операторов. Во-первых, нельзя изменить при­оритет оператора. Во-вторых, нельзя изменить число операндов оператора. 
Операторы . :: * ? не могут быть перегружены.

5. Ключевое слово friend используется в объявлении функции, не являющейся методом класса, для предоставления доступа к полю private (Также может использоваться для предоставления другому классу доступа к полю private данного класса). Так, например, можно определить функцию

friend std::ostream& operator<<(std::ostream& os, const Class_name& c);

которая не является методом класса Class_name, но имеет доступ к его полю private.

6. Главное отличие new и delete по сравнению с malloc() и free() в том, что, кроме выделения и освобождения памяти, new и delete вызывают соответственно конструктор и деструктор типа (класса).
Также в случае неудачи new генерирует исключение bad_alloc, а malloc просто возвращает NULL.